#include "textflag.h"

/* 
在Go语言中使用汇编源码有以下一些规则和特点：

文件命名与位置：汇编语言文件通常以.s或.S为扩展名，并且应放在包的目录内。
.s文件是经过C预处理器处理的（如果使用了的话），而.S文件则需要手动调用预处理器。

GOARCH特定：Go的汇编代码是与目标架构（GOARCH）紧密相关的。
例如，AMD64架构的代码不会在386架构上运行。
因此，需要为不同的架构编写不同的汇编文件，并通过构建标签[1]或文件名后缀字符[2]来区分。

文本段和数据段：Go汇编文件中的函数定义通常以TEXT关键字开始，后面跟着函数名、
代码段的属性（如是否允许分割堆栈NOSPLIT）以及局部变量的大小。数据定义则使用DATA关键字。

参数和返回值：函数参数通过栈传递，第一个参数在栈顶，之后的参数依次向下。返回值通常通过寄存器返回，具体规则依据目标架构而定。

调用约定：Go汇编遵循特定的调用约定，包括如何保存和恢复调用者保存的寄存器，以及如何管理堆栈等。这些约定确保了汇编代码能正确地与其他Go代码交互。

辅助函数和指令：Go汇编支持特定的辅助函数（如runtime·entersyscall用于进入系统调用）和指令，这些是与Go运行时交互的关键部分。

特殊符号：如SB代表当前代码段的起始地址，FP代表当前函数的帧指针，SP代表堆栈指针等，这些符号帮助访问程序状态。

汇编指令：直接使用目标架构的汇编指令集，比如x86架构下的MOV, ADD, CALL等。理解并正确使用这些指令是编写有效汇编代码的基础。

注释和文档：虽然不是强制性的，但良好的注释习惯对于理解复杂的汇编逻辑至关重要，特别是对于维护和团队协作。

与Go代码的交互：可以通过汇编中定义的全局标识符（如变量或函数）来与Go代码交互，但需要注意的是，这些交互必须遵循Go的类型系统和内存模型。

总的来说，Go语言中的汇编编程要求开发者对目标架构的汇编语言有深入理解，同时也需要熟悉Go的运行时机制和调用约定。

 ---
 [1] 在Go中，构建标签（Build Tags）是一种机制，允许你在代码中包含特定条件的代码块，这些代码块只在满足特定条件（如特定操作系统、架构或编译选项）时才会被编译。对于汇编代码，这同样适用，特别是在处理跨平台的代码时。

以下是一个简单的示例，展示了如何使用构建标签来区分不同架构的汇编代码：

go
// +build !arm

// arm64汇编代码，仅在ARM64架构上编译
TEXT ·myFunction(SB), NOSPLIT, $0-0
    // ARM64汇编指令...
    RET

// +build arm

// ARM汇编代码，仅在ARM架构上编译
TEXT ·myFunction(SB), NOSPLIT, $0-0
    // ARM汇编指令...
    RET
在这个例子中，// +build !arm 标签表示这段代码将在所有非ARM架构上编译，而// +build arm 表示这段代码仅在ARM架构上编译。当使用go build或go run命令时，Go编译器会自动处理这些标签，只编译匹配当前构建环境的代码。

请注意，这样的代码组织方式意味着你需要为每个支持的架构编写单独的汇编代码，而且通常只有在性能关键的场景下才这样做，因为大部分情况下Go的编译器优化已经足够好。

---
[2]能使用不同文件名后缀来标识不同架构上的汇编文件吗? 比如xxx_386.s和xxx_amd64.s之类的命名

是的，可以使用不同文件名后缀来标识不同架构上的汇编文件。这种做法常见于Go项目中，特别是在需要编写特定架构的优化代码时。文件名通常会包含目标架构的名字，以便go build命令能够自动选择正确的文件进行编译。

例如，你可以有以下文件结构：

mypackage/
    mypackage.go
    mypackage_amd64.s     # AMD64架构的汇编代码
    mypackage_386.s       # 386架构的汇编代码
    mypackage_arm.s       # ARM架构的汇编代码
    ...
当使用go build命令构建项目时，Go编译器会自动根据目标架构选择对应的汇编文件。例如，如果你正在AMD64架构上构建，mypackage_amd64.s会被编译，而在386架构上则是mypackage_386.s。这种方式简化了多架构支持的管理，避免了在代码中使用构建标签。

需要注意的是，这种文件命名约定是基于Go的构建系统默认的行为，不需要在代码中显式声明或处理这些标签。只要文件命名正确，Go工具链就能正确处理。


 */
/* 
TEXT ·pause(SB), NOSPLIT, $0-4
这里的·pause表示函数pause是当前包内的一个函数。
TEXT是定义代码段的指令，SB（Segment Base）是一个特殊的符号，
通常指向当前代码段的起始地址，用于定位函数的绝对地址。
NOSPLIT表示该函数不进行堆栈分裂操作，即不会调整堆栈以保留足够的空间给调用者使用，
这通常是性能敏感代码中的一种优化手段。
$0-4表示该函数不接受任何参数（$0表示没有入栈参数大小），
并且局部变量占用4字节的栈空间。
总之，点符号.在这里用于明确标识函数或数据是包内定义的，是Go汇编语言语法的一部分。
 */
/* 
这段代码定义了一个名为pause的函数，它接收一个整型参数cnt，
并在汇编语言中实现了延迟操作。具体实现中，使用LOOP指令和PAUSE指令循环cnt次，
达到延迟的效果。其中MOVL指令将参数cnt加载到寄存器CX中，again标签用于循环，
RET指令表示函数返回。这个函数没有使用堆栈分配空间（NOSPLIT），
并且没有其他外部依赖（TEXT ·pause(SB)）。
 */
// void pause(cnt int)
TEXT ·pause(SB), NOSPLIT, $0-4
// 将形参cnt地址中存储的4字节整数值加载到CX寄存器中。
/* cnt+0(FP) 是一个基于帧指针（Frame Pointer, FP）的内存寻址表达式。
在汇编语言中，FP寄存器常用于跟踪函数调用时的栈帧，帮助在递归调用或者有多个
嵌套函数调用时定位局部变量。
cnt 是变量名，表示要访问的变量。
+0 表示cnt相对于FP的偏移量是0，即cnt紧挨着栈帧的顶部。
(FP) 表示使用FP作为基址，进行间接寻址。
所以整体而言，这个表达式指定了栈上cnt变量的位置，汇编指令将其内容移动到CX寄存器中。
*/
	MOVL	cnt+0(FP), CX
again:
	PAUSE
	// LOOP指令会自动从CX寄存器中获取当前的循环计数，并在执行时自动将CX减1。
	// 如果CX减1后不为零，则LOOP指令会跳转回指定的指令标签，继续执行循环。
	// 当CX减至0时，LOOP指令不再跳转，控制流会继续到LOOP指令后面的下一条指令。
	// 这是x86架构中LOOP指令的基本行为，它提供了一种简便的方式来执行固定次数的循环。
	LOOP	again
	RET
